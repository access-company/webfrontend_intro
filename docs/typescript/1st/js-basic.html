<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>JavaScript(TypeScript) 基礎</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="JavaScript(TypeScript) 基礎" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="JavaScript(TypeScript) 基礎" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"JavaScript(TypeScript) 基礎","url":"/webfrontend_intro/typescript/1st/js-basic.html"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style" type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/webfrontend_intro/assets/css/style.css?v=">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/webfrontend_intro/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <a id="skip-to-content" href="#content">Skip to the content.</a>

    <header class="page-header" role="banner">
      <h1 class="project-name">JavaScript(TypeScript) 基礎</h1>
      <h2 class="project-tagline"></h2>
      
      
    </header>

    <main id="content" class="main-content" role="main">
      <h1 id="javascripttypescript-基礎">JavaScript(TypeScript) 基礎</h1>

<h2 id="目次">目次</h2>

<ul>
  <li><a href="#基本的な型">基本的な型</a>
    <ul>
      <li><a href="#データ型">データ型</a></li>
      <li><a href="#リテラル">リテラル</a></li>
    </ul>
  </li>
  <li><a href="#変数宣言">変数宣言</a>
    <ul>
      <li><a href="#const">const</a></li>
      <li><a href="#let">let</a></li>
      <li><a href="#var">var</a></li>
    </ul>
  </li>
  <li><a href="#関数">関数</a>
    <ul>
      <li><a href="#arrow-functiones2015">アロー関数</a></li>
    </ul>
  </li>
  <li><a href="#演算子">演算子</a>
    <ul>
      <li><a href="#基本的な二項演算子">基本的な二項演算子</a></li>
      <li><a href="#比較演算子">比較演算子</a></li>
    </ul>
  </li>
  <li><a href="#暗黙的な型変換">暗黙的な型変換</a></li>
  <li><a href="#条件分岐">条件分岐</a>
    <ul>
      <li><a href="#if文">if 文</a></li>
      <li><a href="#switch文">switch 文</a></li>
    </ul>
  </li>
  <li><a href="#ループ">ループ</a></li>
  <li><a href="#例外処理">例外処理</a>
    <ul>
      <li><a href="#throw構文">throw構文</a></li>
      <li><a href="#try-catch構文">try-catch構文</a></li>
      <li><a href="#finally構文">finally構文</a></li>
    </ul>
  </li>
  <li><a href="#非同期処理">非同期処理</a></li>
</ul>

<h2 id="基本的な型">基本的な型</h2>

<h3 id="データ型">データ型</h3>

<p>JavaScript にはデータ型が存在します。
データ型を大きく分けると以下の 2 つあります。
※ TypeScript は静的型付けなので変数の型も存在します</p>

<ul>
  <li>プリミティブ型
    <ul>
      <li>真偽値（Boolean）: true または false のデータ型</li>
      <li>数値（Number）: 42 や 3.14159 などの数値のデータ型</li>
      <li>巨大な整数（BigInt）: ES2020 から追加された 9007199254740992n などの任意精度の整数のデータ型</li>
      <li>文字列（String）: “JavaScript” などの文字列のデータ型</li>
      <li>undefined: 値が未定義であることを意味するデータ型</li>
      <li>null: 値が存在しないことを意味するデータ型</li>
      <li>シンボル（Symbol）: ES2015 から追加された一意で不変な値のデータ型</li>
    </ul>
  </li>
  <li>オブジェクト(複合型)
    <ul>
      <li>プリミティブ型以外のデータ</li>
      <li>オブジェクト、配列、関数、正規表現、Date など</li>
    </ul>
  </li>
</ul>

<p>TypeScript では以下に置き換えて型定義を行います。</p>

<ul>
  <li>string: 文字列
    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">taro</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>number: 全ての Numeric の値
    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">num</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>boolean: 真偽値
    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">isValid</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>undefined: undefined
    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">undefinedValue</span><span class="p">:</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>null: null
    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">nullValue</span><span class="p">:</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>never: 値を持たない型</p>

    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">error</span> <span class="o">=</span> <span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">never</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">infiniteLoop</span> <span class="o">=</span> <span class="p">():</span> <span class="nx">never</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">while </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div>    </div>
  </li>
</ul>

<details><summary>Advanced</summary>

- any
  `any` 型はそれ以降の型チェックはスルーされる
  `any` を使うと JavaScript で書くのと変わらないため、極力使わない

  ```ts
  let obj: any = { x: 0 };

  obj.foo();
  obj();
  obj.bar = 100;
  obj = "hello";
  const n: number = obj;
  ```

  正しいコードを書いていても稀に TypeScript の型推論能力が足りなくてエラーになることなどがある。
  そう言った場合にやむなく使うケースがある。

- array
  `[1, 2, 3]` のような配列の型を定義するには、`number[]` と出来ます。
  この構文は、どのタイプでも機能します（文字列の配列は `string[]` など）
  ```ts
  const numList: number[] = [1, 2, 3];
  ```
- tuple
  複数の要素を管理するデータ型
  ```ts
  const foo: [string, number] = ["foo", 1];
  ```
- void
  関数が何も値を返さない時にセットされる型
  ```ts
  function func(value: string): void {
    console.log(value);
  }
  ```
- enum
  列挙型
  ```ts
  enum Gender {
    Male = "male",
    Female = "female",
  }
  const gender: Gender = Gender.Male;
  ```
- string literal
  文字列リテラルの型

  ```ts
  const name1: "taro" = "taro";
  const name2: "taro" = "jiro"; // コンパイルエラー Initializer type "jiro" is not assignable to variable type "taro"
  ```

  - widening literal と NonWidening literal

    - widening literal の場合、 literal type の値を別の変数に代入した場合に普通の型推論の型となってしまう

    ```ts
    const widening = "taro"; // widening: 'taro'
    const obj1 = {
      widening, // obj1.widening: string
    };

    obj1.widening = "jiro"; // !?

    const nonWidening = "hoge" as const; // nonWidening: 'hoge'
    const obj2 = {
      nonWidening, // obj2.nonWidening: 'hoge'
    };

    obj2.nonWidening = "fuga"; // コンパイルエラー Assigned expression type "fuga" is not assignable to type "hoge"
    ```

- optional property
  オブジェクトプロパティをオプショナル(任意)なプロパティとして定義

  ```ts
  type User = {
    name: string;
    age: number;
    gender?: string;
  };
  ```

</details>

<h3 id="リテラル">リテラル</h3>

<p>プリミティブ型の値や一部のオブジェクトは、リテラルを使うことで簡単に定義できるようになっています。</p>

<ul>
  <li>真偽値
真偽値には <code class="language-plaintext highlighter-rouge">true</code> と <code class="language-plaintext highlighter-rouge">false</code> のリテラルがあります。</li>
  <li>数値
数値には 42 のような整数リテラルと 3.14159 のような浮動小数点数リテラルがあります。</li>
  <li>文字列
文字列リテラル共通のルールとして、同じクォーテーション記号で囲んだ内容を文字列として扱います。
    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">文字列</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// =&gt; "文字列"</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">文字列</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// =&gt; "文字列"</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`文字列`</span><span class="p">);</span> <span class="c1">// =&gt; "文字列"</span>
</code></pre></div>    </div>
    <ul>
      <li>`（バッククォート）で囲んだ文字列リテラルはテンプレートリテラルと言います。
テンプレートリテラルでは、複数行の文字列を改行記号のエスケープシーケンス（\n）を使わずにそのまま書くことができます。
また、テンプレートリテラル内で <code class="language-plaintext highlighter-rouge">${変数名}</code> と書いた場合に、その変数の値を埋め込むことができます。</li>
    </ul>
  </li>
  <li>null
null リテラルは <code class="language-plaintext highlighter-rouge">null</code> 値を返すリテラルです。</li>
  <li>オブジェクト
<code class="language-plaintext highlighter-rouge">{}</code>（中カッコ）を書くことで、新しいオブジェクトを作成できます。
※ <code class="language-plaintext highlighter-rouge">{}</code> はオブジェクトリテラルなので <code class="language-plaintext highlighter-rouge">{} === {}</code> は <code class="language-plaintext highlighter-rouge">false</code> になります。</li>
  <li>配列
<code class="language-plaintext highlighter-rouge">[</code> と <code class="language-plaintext highlighter-rouge">]</code> で値をカンマ区切りで囲み、その値を持つ Array オブジェクトを作成します</li>
  <li>正規表現
正規表現リテラルは <code class="language-plaintext highlighter-rouge">/</code>（スラッシュ）と <code class="language-plaintext highlighter-rouge">/</code>（スラッシュ）で正規表現のパターン文字列を囲みます。</li>
</ul>

<h4 id="演習問題">演習問題</h4>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/standard/exercise1.ts</code> を解いてみてください。</p>

<h2 id="変数宣言">変数宣言</h2>

<p>JavaScript の変数宣言の種類</p>

<ul>
  <li>const(ES2015)
再代入できない変数の宣言とその変数が参照する値（初期値）を定義</li>
  <li>let(ES2015)
値の再代入が可能な変数を宣言</li>
  <li>var
値の再代入が可能な変数を宣言</li>
</ul>

<h3 id="const">const</h3>

<p>次のように、<code class="language-plaintext highlighter-rouge">const</code> キーワードに続いて <code class="language-plaintext highlighter-rouge">変数名</code> を書き、代入演算子（=）の右辺に変数の <code class="language-plaintext highlighter-rouge">初期値</code> を書いて変数を定義できます。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">変数名</span> <span class="o">=</span> <span class="nx">初期値</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">const</code> は再代入できない変数を宣言するキーワードです。
そのため、<code class="language-plaintext highlighter-rouge">const</code> キーワードで宣言した変数に対して、後から値を代入することはできません。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">taro</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">jiro</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// エラー</span>
</code></pre></div></div>

<p>TypeScript で書いた場合</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">taro</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p>※イミュータビリティを考慮して、基本的には <code class="language-plaintext highlighter-rouge">const</code> を使うことを意識すると良いです。</p>

<h3 id="let">let</h3>

<p>変数定義の書き方としては <code class="language-plaintext highlighter-rouge">const</code> と同様です。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">変数名</span> <span class="o">=</span> <span class="nx">初期値</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">let</code> は <code class="language-plaintext highlighter-rouge">const</code> とは異なり、初期値を指定しない変数も定義できます。
初期値が指定されなかった変数はデフォルト値として <code class="language-plaintext highlighter-rouge">undefined</code> という値で初期化されます。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">name</span><span class="p">;</span>
<span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">jiro</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p>TypeScript で書いた場合</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">jiro</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p>昨今のコーディングでは、 <code class="language-plaintext highlighter-rouge">const</code> が一般的なので、 <code class="language-plaintext highlighter-rouge">let</code> を使う場合は、「この変数は再代入される可能性がある」という表明をする時のみ使うと良いです。</p>

<h3 id="var">var</h3>

<p><code class="language-plaintext highlighter-rouge">var</code> キーワードでは、値の再代入が可能な変数を宣言できます。
<code class="language-plaintext highlighter-rouge">var</code> の使い方は <code class="language-plaintext highlighter-rouge">let</code> とほとんど同じです。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">name</span><span class="p">;</span>
<span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">jiro</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">var</code> には、同じ名前の変数を再定義できてしまう問題があります。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">taro</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">jiro</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// name は 'jiro' になる</span>
</code></pre></div></div>

<p>また、 <code class="language-plaintext highlighter-rouge">var</code> は <code class="language-plaintext highlighter-rouge">変数の巻き上げ</code> という問題も発生します。</p>

<p>ES2015 で追加された <code class="language-plaintext highlighter-rouge">const</code> , <code class="language-plaintext highlighter-rouge">let</code> はこれらの問題が解消されています。
<code class="language-plaintext highlighter-rouge">var</code> を人間が使わなければならない場面は無いので、原則使わないようにしましょう。
※ 今でも <code class="language-plaintext highlighter-rouge">var</code> が残っているのは後方互換のためです。</p>

<h4 id="演習問題-1">演習問題</h4>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/standard/exercise2.ts</code> を解いてみてください。</p>

<h2 id="関数">関数</h2>

<p>関数とは、ある一連の手続き（文の集まり）を 1 つの処理としてまとめる機能です。
関数を利用することで、同じ処理を毎回書くのではなく、一度定義した関数を呼び出すことで同じ処理を実行できます。</p>

<p>JavaScript では、関数を定義するために <code class="language-plaintext highlighter-rouge">function</code> キーワードを使います。
<code class="language-plaintext highlighter-rouge">function</code> からはじまる文は関数宣言と呼び、次のように関数を定義できます。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 関数宣言</span>
<span class="kd">function</span> <span class="nf">関数名</span><span class="p">(</span><span class="nx">仮引数1</span><span class="p">,</span> <span class="nx">仮引数2</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 関数が呼び出されたときの処理</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="nx">関数の返り値</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 関数呼び出し</span>
<span class="kd">const</span> <span class="nx">関数の結果</span> <span class="o">=</span> <span class="nf">関数名</span><span class="p">(</span><span class="nx">引数1</span><span class="p">,</span> <span class="nx">引数2</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">関数の結果</span><span class="p">);</span> <span class="c1">// =&gt; 関数の返り値</span>
</code></pre></div></div>

<p>TypeScript の場合は、仮引数と返り値に対して型注釈を行う。</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">num1</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">num2</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="arrow-functiones2015">Arrow-function(ES2015)</h3>

<p>関数式には <code class="language-plaintext highlighter-rouge">function</code> キーワードを使った方法以外に、<code class="language-plaintext highlighter-rouge">Arrow Function</code> と呼ばれる書き方があります。
名前のとおり矢印のような <code class="language-plaintext highlighter-rouge">=&gt;（イコールと大なり記号）</code> を使い、匿名関数を定義する構文です。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Arrow Functionを使った関数定義</span>
<span class="kd">const</span> <span class="nx">関数名</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 関数を呼び出したときの処理</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="nx">関数の返す値</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Arrow Function には省略記法があり、次の場合にはさらに短く書けます。</p>

<ul>
  <li>関数の仮引数が 1 つのときは <code class="language-plaintext highlighter-rouge">()</code> を省略できる</li>
  <li>関数の処理が 1 つの式である場合に、ブロックと <code class="language-plaintext highlighter-rouge">return</code> 文を省略できる
    <ul>
      <li>その式の評価結果を <code class="language-plaintext highlighter-rouge">return</code> の返り値とする</li>
    </ul>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 仮引数の数と定義</span>
<span class="kd">const</span> <span class="nx">fnA</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="cm">/* 仮引数がないとき */</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="nx">fnB</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="cm">/* 仮引数が1つのみのとき */</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="nx">fnC</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="cm">/* 仮引数が1つのみのときは()を省略可能 */</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="nx">fnD</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="cm">/* 仮引数が複数のとき */</span>
<span class="p">};</span>
<span class="c1">// 値の返し方</span>
<span class="c1">// 次の２つの定義は同じ意味となる</span>
<span class="kd">const</span> <span class="nx">mulA</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">};</span> <span class="c1">// ブロックの中でreturn</span>
<span class="kd">const</span> <span class="nx">mulB</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// 1行のみの場合はreturnとブロックを省略できる</span>
</code></pre></div></div>

<p>Arrow Function については次のような特徴があります。</p>

<ul>
  <li>名前をつけることができない（常に匿名関数）
    <ul>
      <li>fnA などは変数名で匿名関数を変数に代入しているというイメージ</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">this</code> が静的に決定できる</li>
  <li><code class="language-plaintext highlighter-rouge">function</code> キーワードに比べて短く書くことができる</li>
  <li><code class="language-plaintext highlighter-rouge">new</code> できない（コンストラクタ関数ではない）</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">arguments</code> 変数を参照できない</p>

    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arguments</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">hoge</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">regular</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">arrow</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
<span class="p">};</span>

<span class="nf">regular</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">//=&gt; [Arguments] { '0': 1, '1': 2 }</span>
<span class="nf">arrow</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">//=&gt; hoge</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">function</code> キーワードと Arrow Function の大きな違いとして、<code class="language-plaintext highlighter-rouge">this</code> という特殊なキーワードに関する挙動の違いがあります。
Arrow Function ではこの <code class="language-plaintext highlighter-rouge">this</code> の問題の多くを解決できるという利点があります。</p>

<p>TypeScript の場合は、仮引数と返り値に対して型注釈を行う。</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num1</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">num2</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<details><summary>Advanced</summary>

Arrow Function 以外の関数（メソッドも含む）における `this` は、実行時に決まる値となります。
言い方を変えると `this` は関数に渡される暗黙的な引数のようなもので、その渡される値は関数を実行するときに決まります。

関数における `this` の基本的な参照先（暗黙的に関数に渡す `this` の値）はベースオブジェクトとなります。
ベースオブジェクトとは「メソッドを呼ぶ際に、そのメソッドのドット演算子またはブラケット演算子のひとつ左にあるオブジェクト」のことを言います。
ベースオブジェクトがない場合の `this` は `undefined` となります。

```js
// `fn`関数はメソッドではないのでベースオブジェクトはない
fn();
// `obj.method`メソッドのベースオブジェクトは`obj`
obj.method();
// `obj1.obj2.method`メソッドのベースオブジェクトは`obj2`
// ドット演算子、ブラケット演算子どちらも結果は同じ
obj1.obj2.method();
obj1["obj2"]["method"]();
```

`this` の問題の原因は `this` がどの値を参照するかは関数の呼び出し時に決まるという性質に由来します。
この `this` の性質が問題となるパターンの代表的な 2 つの例とそれぞれの対策について見ていきます。

- `this` を含むメソッドを変数に代入した場合
  ```js
  "use strict";
  const person = {
    fullName: "Brendan Eich",
    sayName: function () {
      // `this` は呼び出し元によって異なる
      return this.fullName``;
    },
  };
  // `sayName` メソッドは `person` オブジェクトに所属する
  // `this` は `person` オブジェクトとなる
  console.log(person.sayName()); // =&gt; 'Brendan Eich'
  // `person.sayName` を `say` 変数に代入する
  const say = person.sayName;
  // 代入したメソッドを関数として呼ぶ
  // この `say` 関数はどのオブジェクトにも所属していない
  // `this` は `undefined` となるため例外を投げる
  say(); // =&gt; TypeError: Cannot read property 'fullName' of undefined
  ```
- コールバック関数の中で `this` を参照する場合
  ```js
  "use strict";
  // strict modeを明示しているのは、thisがグローバルオブジェクトに暗黙的に変換されるのを防止するため
  const Prefixer = {
    prefix: "pre",
    /**
     * `strings` 配列の各要素に prefix をつける
     */
    prefixArray(strings) {
      return strings.map(function (str) {
        // コールバック関数における `this` は `undefined` となる(strict mode)
        // そのため `this.prefix` は `undefined.prefix` となり例外が発生する
        return this.prefix + "-" + str;
      });
    },
  };
  // `prefixArray` メソッドにおける `this` は `Prefixer`
  Prefixer.prefixArray(["a", "b", "c"]); // =&gt; TypeError: Cannot read property 'prefix' of undefined
  ```

</details>

<h4 id="演習問題-2">演習問題</h4>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/standard/exercise3.ts</code> を解いてみてください。</p>

<h2 id="演算子">演算子</h2>

<p>算子はよく利用する演算処理を記号などで表現したものです。
演算子は演算する対象を持ちます。この演算子の対象のことを <code class="language-plaintext highlighter-rouge">被演算子（オペランド）</code> と呼びます。</p>

<p>次のコードでは、 <code class="language-plaintext highlighter-rouge">+</code> 演算子が値同士を足し算する加算演算を行っています。
このとき、 <code class="language-plaintext highlighter-rouge">+</code> 演算子の対象となっている <code class="language-plaintext highlighter-rouge">1</code> と <code class="language-plaintext highlighter-rouge">2</code> という 2 つの値がオペランドです。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>このコードでは <code class="language-plaintext highlighter-rouge">+</code> 演算子に対して、前後に合計 2 つのオペランドがあります。
このように、2 つのオペランドを取る演算子を <code class="language-plaintext highlighter-rouge">二項演算子</code> と呼びます。</p>

<h3 id="基本的な二項演算子">基本的な二項演算子</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">+</code>
2 つの数値を加算する演算子です。
文字列の結合にも利用できます。</li>
  <li><code class="language-plaintext highlighter-rouge">-</code>
2 つの数値を減算する演算子です。</li>
  <li><code class="language-plaintext highlighter-rouge">*</code>
2 つの数値を乗算する演算子です。</li>
  <li><code class="language-plaintext highlighter-rouge">/</code>
2 つの数値を除算する演算子です。</li>
  <li><code class="language-plaintext highlighter-rouge">%</code>
2 つの数値のあまりを求める演算子です。
左オペランドを右オペランドで除算したあまりを返します。</li>
  <li><code class="language-plaintext highlighter-rouge">**</code>(ES2016)
2 つの数値のべき乗を求める演算子です。
左オペランドを右オペランドでべき乗した値を返します。</li>
</ul>

<h3 id="比較演算子">比較演算子</h3>

<p>比較演算子はオペランド同士の値を比較し、真偽値を返す演算子です。</p>

<ul>
  <li>厳密等価演算子( <code class="language-plaintext highlighter-rouge">===</code> )
厳密等価演算子は、左右の 2 つのオペランドを比較します。
同じ型で同じ値である場合に、<code class="language-plaintext highlighter-rouge">true</code> を返します。
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">===</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// =&gt; false</span>
</code></pre></div>    </div>
  </li>
  <li>厳密不等価演算子( <code class="language-plaintext highlighter-rouge">!==</code> )
厳密不等価演算子は、左右の 2 つのオペランドを比較します。
異なる型または異なる値である場合に、<code class="language-plaintext highlighter-rouge">true</code> を返します。</li>
  <li>等価演算子( <code class="language-plaintext highlighter-rouge">==</code> )
等価演算子は、2 つのオペランドを比較します。
同じデータ型のオペランドを比較する場合は、厳密等価演算子と同じ結果になります。
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
</code></pre></div>    </div>
    <p>等価演算子は厳密等価演算子とは異なり、 <code class="language-plaintext highlighter-rouge">暗黙的な型変換</code> をしてから比較します。
これは意図しない挙動を生むため、基本的には厳密等価演算子を使うようにしましょう。</p>
  </li>
  <li>不等価演算子( <code class="language-plaintext highlighter-rouge">!=</code> )
不等価演算子は、2 つのオペランドを比較します。
等しくないなら <code class="language-plaintext highlighter-rouge">true</code> を返します。
こちらも暗黙的な型変換が行われるため、使用を控えましょう。</li>
  <li>大小の比較演算子( <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code> )
左右オペランドの大小を比較する演算子です。
左オペランドが右オペランドより、「より大きい(&gt;)、以上(&gt;=)、より小さい(&lt;)、以下(&lt;=)」の時に <code class="language-plaintext highlighter-rouge">true</code> を返します。</li>
</ul>

<p>TypeScript の場合も、これらの演算子の使い方は同じです。</p>

<h4 id="演習問題-3">演習問題</h4>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/standard/exercise4.ts</code> を解いてみてください。</p>

<h2 id="暗黙的な型変換">暗黙的な型変換</h2>

<p>「ある処理において、その処理過程で行われる明示的ではない型変換」のことを暗黙的な型変換と言います。
暗黙的な型変換は、演算子による演算や関数の処理過程で行われます。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 異なる型である場合に暗黙的な型変換が行われる</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="kc">false</span><span class="p">);</span> <span class="c1">// =&gt; true</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">10</span> <span class="o">==</span> <span class="p">[</span><span class="dl">"</span><span class="s2">10</span><span class="dl">"</span><span class="p">]);</span> <span class="c1">// =&gt; true</span>

<span class="mi">1</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// =&gt; '12'</span>
<span class="mi">1</span> <span class="o">-</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// =&gt; -1　文字列に対するマイナス演算子の定義は無いため、数値に変換される</span>

<span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="nx">y</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// =&gt; '123'</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// =&gt; '213'</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">z</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// =&gt; '42'</span>
</code></pre></div></div>

<p>暗黙的型変換は意図しない結果となりやすいので避けましょう。
厳密等価演算子を使うことや、リテラルやコンストラクタ関数を使って明示的な型変換を行う事で大体は回避できます。
※ TypeScript を使うことでも解消できます。</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">stringValue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">`</span><span class="p">${</span><span class="nx">x</span><span class="p">}${</span><span class="nx">y</span><span class="p">}${</span><span class="nx">z</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">numberValue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">z</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="o">+</span> <span class="nx">z</span><span class="p">;</span> <span class="c1">// NaN には注意</span>
<span class="p">};</span>
</code></pre></div></div>

<p>TypeScript で返り値の型を縛る事で、実装者が意図しない型変換に気付ける場合もあります。</p>

<h2 id="条件分岐">条件分岐</h2>

<p>条件分岐を使うことで、特定の条件を満たすかどうかで行う処理を変更できます。</p>

<h3 id="if-文">if 文</h3>

<p>if 文を使うことで、プログラム内に条件分岐を書けます。
if 文は次のような構文が基本形となります。 <code class="language-plaintext highlighter-rouge">条件式</code> の評価結果が <code class="language-plaintext highlighter-rouge">true</code> であるならば、 <code class="language-plaintext highlighter-rouge">実行する文</code> が実行されます。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">条件式</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">実行する文</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>if 文の条件式には <code class="language-plaintext highlighter-rouge">true</code> または <code class="language-plaintext highlighter-rouge">false</code> といった真偽値以外の値も指定できます。
真偽値以外の値の場合、その値を暗黙的に真偽値へ変換してから、条件式として判定します。
次の値は真偽値へと変換すると <code class="language-plaintext highlighter-rouge">false</code> となるため、これらの値は <code class="language-plaintext highlighter-rouge">falsy</code> と呼ばれます</p>

<ul>
  <li>false</li>
  <li>undefined</li>
  <li>null</li>
  <li>0</li>
  <li>0n</li>
  <li>NaN</li>
  <li>”“（空文字列）</li>
</ul>

<p>複数の条件分岐を書く場合は、if 文に続けて <code class="language-plaintext highlighter-rouge">else if</code> 文を使うことで書けます。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">version</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">ES6</span><span class="dl">"</span><span class="p">;</span>
<span class="k">if </span><span class="p">(</span><span class="nx">version</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">ES5</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">ECMAScript 5</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">version</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">ES6</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">ECMAScript 2015</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">version</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">ES7</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">ECMAScript 2016</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>条件に一致しなかった場合の処理は、 <code class="language-plaintext highlighter-rouge">else</code> 文を使うことで書けます。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">if </span><span class="p">(</span><span class="nx">num</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`numは10より大きいです: </span><span class="p">${</span><span class="nx">num</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`numは10以下です: </span><span class="p">${</span><span class="nx">num</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>TypeScript の場合も、使い方は同じです。</p>

<h3 id="switch-文">switch 文</h3>

<p>switch 文は、次のような構文で <code class="language-plaintext highlighter-rouge">式</code> の評価結果が指定した値である場合に行う処理を並べて書きます。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch </span><span class="p">(</span><span class="nx">式</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">ラベル1</span><span class="p">:</span>
    <span class="c1">// `式`の評価結果が`ラベル1`と一致する場合に実行する文</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="nx">ラベル2</span><span class="p">:</span>
    <span class="c1">// `式`の評価結果が`ラベル2`と一致する場合に実行する文</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="nl">default</span><span class="p">:</span>
    <span class="c1">// どのcaseにも該当しない場合の処理</span>
    <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// break後はここから実行される</span>
</code></pre></div></div>

<p>switch 文の <code class="language-plaintext highlighter-rouge">case</code> 節では基本的に <code class="language-plaintext highlighter-rouge">break</code> を使って switch 文を抜けるようにします。
この <code class="language-plaintext highlighter-rouge">break</code> は省略が可能ですが、省略した場合、後ろに続く <code class="language-plaintext highlighter-rouge">case</code> 節が条件に関係なく実行されます。</p>

<p>switch 文は if 文の代用として使うのではなく、次のように関数と組み合わせて条件に対する値を返すパターンとして使うことが多いです。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getECMAScriptName</span> <span class="o">=</span> <span class="p">(</span><span class="nx">version</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">switch </span><span class="p">(</span><span class="nx">version</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">ES5</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">"</span><span class="s2">ECMAScript 5</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">ES6</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">"</span><span class="s2">ECMAScript 2015</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">ES7</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">"</span><span class="s2">ECMAScript 2016</span><span class="dl">"</span><span class="p">;</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">"</span><span class="s2">しらないバージョンです</span><span class="dl">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// 関数を実行して`return`された値を得る</span>
<span class="nf">getECMAScriptName</span><span class="p">(</span><span class="dl">"</span><span class="s2">ES6</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// =&gt; 'ECMAScript 2015'</span>
</code></pre></div></div>

<p>TypeScript の場合も、使い方は同じです。</p>

<h2 id="ループ">ループ</h2>

<p>反復処理には <code class="language-plaintext highlighter-rouge">for文</code> や <code class="language-plaintext highlighter-rouge">while文</code>, 配列のインスタンスメソッドなどがあります。</p>

<p>イミュータビリティを考慮し、今回は配列のインスタンスメソッドの一部を例として解説していきます。</p>

<p><code class="language-plaintext highlighter-rouge">Array.prototype.map</code> を使う</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Array.prototype.map</code> メソッドは、与えられた関数を配列のすべての要素に対して呼び出し、その結果からなる <strong>新しい配列</strong> を生成します。
この「新しい配列を生成する」部分が重要で、基の <code class="language-plaintext highlighter-rouge">array</code> には変更が加えられず、新しい配列 <code class="language-plaintext highlighter-rouge">result</code> が定義されます。</p>

<p>TypeScript の場合も、使い方は同じです。</p>

<details><summary>Advanced</summary>

`Array.prototype.map`の他にもいくつか配列のインスタンスメソッドを紹介します。

- `Array.prototype.some`
  配列内の少なくとも 1 つの要素が指定した関数の条件を満たす場合に true を返す。
  全ての要素が指定した関数の条件を満たさない場合に false を返す。

  ```js
  const array = [1, 2, 3, 4, 5];

  const even = (element) =&gt; element % 2 === 0;

  console.log(array.some(even));
  // true
  ```

- `Array.prototype.every`
  配列内の全ての要素が指定した関数の条件を全て満たす場合に true を返して、一つでも条件を満たさないものがあれば false を返す。

  ```js
  const array = [1, 30, 39, 29, 10, 13];

  const isBelowThreshold = (currentValue) =&gt; currentValue &lt; 40;

  console.log(array1.every(isBelowThreshold));
  // false
  ```

- `Array.prototype.filter`
  指定された配列の中から指定された関数の条件を満たす要素だけを抽出したシャローコピーを作成します。

  ```js
  const ages = [10, 40, 30, 20, 50];
  const result = ages.filter(age =&gt; age &gt;= 18);
  console.log(result);
  // [40, 30, 20, 50]
  ```

- `Array.prototype.reduce`
  隣り合う 2 つの配列要素に対して左から右へ同時に関数を適用し、単一の値にする。

  ```js
  const array1 = [1, 2, 3, 4];

  // 0 + 1 + 2 + 3 + 4
  const initialValue = 0;
  const sumWithInitial = array1.reduce(
    (accumulator, currentValue) =&gt; accumulator + currentValue,
    initialValue
  );

  console.log(sumWithInitial);
  // 10
  ```

</details>

<h4 id="演習問題-4">演習問題</h4>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/standard/exercise5.ts</code> を解いてみてください。</p>

<h2 id="例外処理">例外処理</h2>

<p>プログラム中でエラーが発生した時に、そのエラーを throw 構文で投げて try-catch 構文で補足することができます。
これにより、エラーが発生してもプログラムが途中で止まらずエラーに応じた処理を行うことができます。</p>

<h3 id="throw-構文">throw 構文</h3>

<p>throw はエラーを意図的に発生させるためのキーワードです。
エラーが発生した場合、そのエラーを「投げる」ことでエラーを処理する仕組みに渡します。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">network error!</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="try-catch-構文">try-catch 構文</h3>

<p>try-catch 構文はエラーが発生する可能性のあるコードを安全に実行し、エラーが派生した場合にそのエラーを処理するために使います。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">safeDivide</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">number</span><span class="p">):</span> <span class="nx">number</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">b</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">0で割ることはできません</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">/</span> <span class="nx">b</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="dl">"</span><span class="s2">エラーが発生しました:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// デフォルト値を返す</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">safeDivide</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span> <span class="c1">// 5</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">safeDivide</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="c1">// エラーが発生しました: 0で割ることはできません</span>
                                <span class="c1">// 0</span>
</code></pre></div></div>

<h3 id="finally-構文">finally 構文</h3>

<p>try-catch 構文には、finally ブロックを追加することもできます。
finally ブロックは、エラーの有無に関係なく必ず実行されるコードを記述するために使います。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">処理を開始します</span><span class="dl">"</span><span class="p">);</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">エラーが発生しました</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="dl">"</span><span class="s2">エラー:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
<span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">処理が終了しました</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 出力結果:</span>
<span class="c1">// 処理を開始します</span>
<span class="c1">// エラー: エラーが発生しました</span>
<span class="c1">// 処理が終了しました</span>
</code></pre></div></div>

<h2 id="非同期処理">非同期処理</h2>

<p>多くのプログラミング言語にはコードの評価の仕方として、 <code class="language-plaintext highlighter-rouge">同期処理(sync)</code> と <code class="language-plaintext highlighter-rouge">非同期処理(async)</code> という大きな分類があります。</p>

<p><code class="language-plaintext highlighter-rouge">同期処理</code> ではコードを順番に処理していき、ひとつの処理が終わるまで次の処理は行いません。
同期的にブロックする処理があると、ブラウザでは大きな問題となります。
JavaScript は基本的にブラウザのメインスレッドで実行されるため、表示が更新されなくなりフリーズしたようになります。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 指定した`timeout`ミリ秒経過するまで同期的にブロックする関数</span>
<span class="kd">function</span> <span class="nf">blockTime</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">startTime</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nf">now</span><span class="p">();</span>
  <span class="c1">// `timeout`ミリ秒経過するまで無限ループをする</span>
  <span class="k">while </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">diffTime</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">startTime</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">diffTime</span> <span class="o">&gt;=</span> <span class="nx">timeout</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span> <span class="c1">// 指定時間経過したら関数の実行を終了</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">処理を開始</span><span class="dl">"</span><span class="p">);</span>
<span class="nf">blockTime</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span> <span class="c1">// 他の処理を1000ミリ秒（1秒間）ブロックする</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">この行が呼ばれるまで処理が1秒間ブロックされる</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">非同期処理</code> はコードを順番に処理していきますが、ひとつの非同期処理が終わるのを待たずに次の処理を評価します。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 指定した`timeout`ミリ秒経過するまで同期的にブロックする関数</span>
<span class="kd">function</span> <span class="nf">blockTime</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">startTime</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nf">now</span><span class="p">();</span>
  <span class="k">while </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">diffTime</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">startTime</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">diffTime</span> <span class="o">&gt;=</span> <span class="nx">timeout</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span> <span class="c1">// 指定時間経過したら関数の実行を終了</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">1. setTimeoutのコールバック関数を10ミリ秒後に実行します</span><span class="dl">"</span><span class="p">);</span>
<span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">3. ブロックする処理を開始します</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">blockTime</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span> <span class="c1">// 他の処理を1秒間ブロックする</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">4. ブロックする処理が完了しました</span><span class="dl">"</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">10</span><span class="p">);</span>
<span class="c1">// ブロックする処理は非同期なタイミングで呼び出されるので、次の行が先に実行される</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">2. 同期的な処理を実行します</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// ログ</span>
<span class="c1">// setTimeoutのコールバック関数を10ミリ秒後に実行します</span>
<span class="c1">// 同期的な処理を実行します</span>
<span class="c1">// ブロックする処理を開始します</span>
<span class="c1">// ブロックする処理が完了しました</span>
</code></pre></div></div>

<p>TypeScript の場合も、使い方は同じです。</p>

<h3 id="promisees2015">Promise(ES2015)</h3>

<p><code class="language-plaintext highlighter-rouge">Promise</code> は、ES2015 で導入された非同期処理を扱うビルトインオブジェクトです。
<code class="language-plaintext highlighter-rouge">Promise</code> は、オブジェクトという形にして非同期処理を統一的なインターフェースで扱うことを目的にしています。
<code class="language-plaintext highlighter-rouge">Promise</code> は、オブジェクトであるためさまざまなメソッドを持っています。(<code class="language-plaintext highlighter-rouge">then</code>, <code class="language-plaintext highlighter-rouge">catch</code>, <code class="language-plaintext highlighter-rouge">finally</code>)</p>

<p><code class="language-plaintext highlighter-rouge">Promise</code> は <code class="language-plaintext highlighter-rouge">new</code> 演算子で <code class="language-plaintext highlighter-rouge">Promise</code> のインスタンスを作成して利用します。
このときのコンストラクタには <code class="language-plaintext highlighter-rouge">resolve</code> と <code class="language-plaintext highlighter-rouge">reject</code> の 2 つの引数を取る <code class="language-plaintext highlighter-rouge">executor</code> と呼ばれる関数を渡します。
<code class="language-plaintext highlighter-rouge">executor</code> 関数の中で非同期処理を行い、非同期処理が成功した場合は <code class="language-plaintext highlighter-rouge">resolve</code> 関数を呼び、失敗した場合は <code class="language-plaintext highlighter-rouge">reject</code> 関数を呼び出します。</p>

<p><code class="language-plaintext highlighter-rouge">resolve</code> 関数は後述する<code class="language-plaintext highlighter-rouge">then</code>に渡されるべき、非同期処理の結果を受け付けます。
<code class="language-plaintext highlighter-rouge">reject</code> 関数は後述する<code class="language-plaintext highlighter-rouge">catch</code>に渡されるべき、非同期処理のエラー結果を受け付けます。エラー結果は Error インスタンスであるべきです。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">executor</span> <span class="o">=</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 非同期の処理が成功したときはresolveを呼ぶ</span>
  <span class="c1">// 非同期の処理が失敗したときはrejectを呼ぶ</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">(</span><span class="nx">executor</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Promise#then</code> メソッドの第一引数には <code class="language-plaintext highlighter-rouge">resolve（成功）</code> 時に呼ばれるコールバック関数、第二引数には <code class="language-plaintext highlighter-rouge">reject（失敗）</code> 時に呼ばれるコールバック関数を渡します。
<code class="language-plaintext highlighter-rouge">Promise#catch</code> メソッドの引数には <code class="language-plaintext highlighter-rouge">reject（失敗）</code> 時に呼ばれるコールバック関数を渡します。</p>

<p>次のコードでは <code class="language-plaintext highlighter-rouge">then</code> メソッドと <code class="language-plaintext highlighter-rouge">catch</code> メソッドで失敗時のエラー処理をしていますが、どちらも同じ意味となります。
<code class="language-plaintext highlighter-rouge">then</code> メソッドに <code class="language-plaintext highlighter-rouge">undefined</code> を渡すのはわかりにくいため、失敗時の処理だけを登録する場合は <code class="language-plaintext highlighter-rouge">catch</code> メソッドの利用を推奨しています。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">errorPromise</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nf">reject</span><span class="p">(</span><span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">));</span>
  <span class="p">});</span>
<span class="p">}</span>
<span class="c1">// 非推奨: `then`メソッドで失敗時のコールバック関数だけを登録</span>
<span class="nf">errorPromise</span><span class="p">(</span><span class="dl">"</span><span class="s2">thenでエラーハンドリング</span><span class="dl">"</span><span class="p">).</span><span class="nf">then</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// =&gt; 'thenでエラーハンドリング'</span>
<span class="p">});</span>
<span class="c1">// 推奨: `catch`メソッドで失敗時のコールバック関数を登録</span>
<span class="nf">errorPromise</span><span class="p">(</span><span class="dl">"</span><span class="s2">catchでエラーハンドリング</span><span class="dl">"</span><span class="p">).</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// =&gt; 'catchでエラーハンドリング'</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Promise にはいくつかのメソッドが用意されているため 1 つだけ紹介します。
複数の非同期処理が終わるのを待ってから次の処理を実行させたい場合などがあります。
そういった場合は、<code class="language-plaintext highlighter-rouge">Promise.all</code>というメソッドを使用します。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">promise1</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">promise3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nf">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nf">all</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">,</span> <span class="nx">promise3</span><span class="p">]).</span><span class="nf">then</span><span class="p">((</span><span class="nx">values</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">values</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// [3, 42, "foo"]</span>
</code></pre></div></div>

<h3 id="async-functiones2017">Async Function(ES2017)</h3>

<p>ES2017 以降、 <code class="language-plaintext highlighter-rouge">Async Function</code> という非同期処理を行う関数を定義する構文が導入されました。
<code class="language-plaintext highlighter-rouge">Async Function</code> は通常の関数とは異なり、必ず <code class="language-plaintext highlighter-rouge">Promise</code> インスタンスを返す関数を定義する構文です。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">doAsync</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="dl">"</span><span class="s2">値</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// doAsync関数はPromiseを返す</span>
<span class="nf">doAsync</span><span class="p">().</span><span class="nf">then</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// =&gt; '値'</span>
<span class="p">});</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Async Function</code> 内では <code class="language-plaintext highlighter-rouge">await</code> 式という <code class="language-plaintext highlighter-rouge">Promise</code> の非同期処理が完了するまで待つ構文が利用できます。
<code class="language-plaintext highlighter-rouge">await</code> 式を使うことで非同期処理を同期処理のように扱えるため、 <code class="language-plaintext highlighter-rouge">Promise</code> チェーンで実現していた処理の流れを読みやすく書けます。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nf">doAsync</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 非同期処理</span>
<span class="p">}</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">asyncMain</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// doAsyncの非同期処理が完了するまでまつ</span>
  <span class="k">await</span> <span class="nf">doAsync</span><span class="p">();</span>
  <span class="c1">// 次の行はdoAsyncの非同期処理が完了されるまで実行されない</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">この行は非同期処理が完了後に実行される</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<details><summary>Promise で書くと…</summary>

```js
function doAsync() {
  return new Promise((resolve, reject) =&gt; {
    // 非同期処理
    resolve();
  });
}
function asyncMain() {
  // doAsyncの非同期処理が完了するまでまつ
  doAsync().then(() =&gt; {
    // 次の行はdoAsyncの非同期処理が完了されるまで実行されない
    console.log("この行は非同期処理が完了後に実行される");
  });
}
```

</details>

<h4 id="演習問題-5">演習問題</h4>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/standard/exercise6.ts</code> を解いてみてください。</p>

<h4 id="残る問題解いてみよう">残る問題解いてみよう</h4>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/standard/exercise7.ts</code></p>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/standard/exercise8.ts</code></p>


      <footer class="site-footer">
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </main>
  </body>
</html>
