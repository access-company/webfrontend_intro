<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>TypeScript Deep Dive</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="TypeScript Deep Dive" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="TypeScript Deep Dive" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"TypeScript Deep Dive","url":"/webfrontend_intro/typescript/1st_extra/"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style" type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/webfrontend_intro/assets/css/style.css?v=">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/webfrontend_intro/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <a id="skip-to-content" href="#content">Skip to the content.</a>

    <header class="page-header" role="banner">
      <h1 class="project-name">TypeScript Deep Dive</h1>
      <h2 class="project-tagline"></h2>
      
      
    </header>

    <main id="content" class="main-content" role="main">
      <h1 id="typescript-deep-dive">TypeScript Deep Dive</h1>

<h2 id="目次">目次</h2>

<ul>
  <li><a href="#Optional-and-Default-Parameters">Optional and Default Parameters</a>
    <ul>
      <li><a href="#Optional-Parameters">Optional Parameters</a></li>
      <li><a href="#Default-Parameters">Default Parameters</a></li>
    </ul>
  </li>
  <li><a href="#Basic-Types">Basic Types</a>
    <ul>
      <li><a href="#Union-Types">Union Type</a></li>
      <li><a href="#Intersection-Types">Intersection Type</a>
        <ul>
          <li><a href="#mapped-types">Mapped Type</a></li>
          <li><a href="#conditional-types">Conditional Type</a></li>
          <li><a href="#generics">Generics</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Non-null-assertion">Non-null assertion</a></li>
  <li><a href="#Optional-Chaining">Optional Chaining</a></li>
  <li><a href="#Nullish-Coalescing">Nullish Coalescing</a></li>
</ul>

<h2 id="optional-and-default-parameters">Optional-and-Default-Parameters</h2>

<h3 id="optional-parameters">Optional Parameters（☆☆☆☆☆）</h3>

<p><code class="language-plaintext highlighter-rouge">?</code> を用いる事でパラメータを省略可能であると表せます。
optional なパラメータは required なパラメータの最後に記述しなければなりません。
optional なパラメータが省略された場合は <code class="language-plaintext highlighter-rouge">undefined</code> が入ります。</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">log</span><span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">userName</span><span class="p">?:</span> <span class="kr">string</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">userName</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`guest: </span><span class="p">${</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">userName</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// OK -&gt; guest: hello</span>
<span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">taro</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// OK -&gt; taro: hello</span>
</code></pre></div></div>

<h4 id="演習問題">演習問題</h4>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/advanced/exercise1.ts</code> を解いてみてください。</p>

<h3 id="default-parameters">Default Parameters（☆☆☆）</h3>

<p>関数の引数の後に <code class="language-plaintext highlighter-rouge">= ***</code> で引数のデフォルト値を指定出来ます。
関数の引数の場合、デフォルトパラメータを指定しておく場合も多いです。
デフォルトパラメータを指定する場合、順序に決まりはありません。</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">log</span><span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">userName</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">guest</span><span class="dl">"</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">userName</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// OK -&gt; guest: hello</span>
<span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">jiro</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// OK -&gt; jiro: hello</span>
</code></pre></div></div>

<h4 id="演習問題-1">演習問題</h4>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/advanced/exercise2.ts</code> を解いてみてください。</p>

<h2 id="basic-types">Basic-Types</h2>

<p>TypeScript の型システムを使用すると、さまざまな演算子を使用して、既存の型から新しい型を構築できます。
いくつかピックアップして解説していきます。</p>

<h3 id="union-types">Union-Types（☆☆☆）</h3>

<p>値が複数の型のどれかに当てはまるような型を表します。
<code class="language-plaintext highlighter-rouge">|</code> で繋いで表現をします。
Optional Parameters は実質 <code class="language-plaintext highlighter-rouge">undefined</code> との Union Types と言えます。</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">value</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// value は文字列型か数値型を持つ</span>

<span class="nx">value</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">taro</span><span class="dl">"</span><span class="p">;</span> <span class="c1">//OK</span>
<span class="nx">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// OK</span>
<span class="nx">value</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// コンパイルエラー</span>
</code></pre></div></div>

<h4 id="演習問題-2">演習問題</h4>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/advanced/exercise3.ts</code> を解いてみてください。</p>

<h3 id="intersection-types">Intersection-Types（☆☆☆）</h3>

<p>指定した型の両方を満たす型を表します。
<code class="language-plaintext highlighter-rouge">&amp;</code> で繋いで表現をします。</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Hoge</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">foo</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">bar</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">type</span> <span class="nx">Fuga</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">foo</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">baz</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">obj1</span><span class="p">:</span> <span class="nx">Hoge</span> <span class="o">&amp;</span> <span class="nx">Fuga</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">foo</span><span class="p">:</span> <span class="dl">"</span><span class="s2">taro</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">bar</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="na">baz</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">obj2</span><span class="p">:</span> <span class="nx">Hoge</span> <span class="o">&amp;</span> <span class="nx">Fuga</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// baz を持っていないのでコンパイルエラー</span>
  <span class="na">foo</span><span class="p">:</span> <span class="dl">"</span><span class="s2">jiro</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">bar</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="演習問題-3">演習問題</h4>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/advanced/exercise4.ts</code> を解いてみてください。</p>

<details><summary>Advanced</summary>

- `type` で `interface` の `Declaration Merging` を表現する例

```ts
// interface の場合
interface IHoge {
  foo: string;
  bar: boolean;
}
interface IHoge {
  baz: number;
}
const obj1: IHoge = {
  foo: "taro",
  bar: false,
  baz: 1,
};

// type の場合
type THoge = {
  foo: string;
  bar: boolean;
};
type TFuga = {
  baz: number;
};
const obj2: THoge &amp; TFuga = {
  foo: "taro",
  bar: false,
  baz: 1,
};
```

</details>

<h3 id="generics">Generics（☆☆）</h3>

<p>型定義の中で型変数を持てます。
名前の後に <code class="language-plaintext highlighter-rouge">&lt; &gt;</code> で囲った名前の列を与えて表現をします。</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Foo</span><span class="o">&lt;</span><span class="nx">S</span><span class="p">,</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">foo</span><span class="p">:</span> <span class="nx">S</span><span class="p">;</span>
  <span class="nl">bar</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">obj1</span><span class="p">:</span> <span class="nx">Foo</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">foo</span><span class="p">:</span> <span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">bar</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">obj2</span><span class="p">:</span> <span class="nx">Foo</span><span class="o">&lt;</span><span class="kr">number</span><span class="p">,</span> <span class="kr">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">foo</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="na">bar</span><span class="p">:</span> <span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>上記コードのようにすると、 <code class="language-plaintext highlighter-rouge">Foo</code> は２つの型変数 <code class="language-plaintext highlighter-rouge">S</code>, <code class="language-plaintext highlighter-rouge">T</code> を持ち、 <code class="language-plaintext highlighter-rouge">foo</code> , <code class="language-plaintext highlighter-rouge">bar</code> が型変数 <code class="language-plaintext highlighter-rouge">S</code>, <code class="language-plaintext highlighter-rouge">T</code> の型となる object の型を表します。
そのため、 <code class="language-plaintext highlighter-rouge">Foo&lt;string, number&gt;</code> とすると、その型を持つ変数は <code class="language-plaintext highlighter-rouge">foo: string</code> , <code class="language-plaintext highlighter-rouge">bar: number</code> を持つ object となります。
このように動的に型を指定することができるので、より再利用性が高い柔軟なコードを書くことができます。</p>

<h4 id="演習問題-4">演習問題</h4>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/advanced/exercise5.ts</code> を解いてみてください。</p>

<h3 id="mapped-types">Mapped-Types（☆）</h3>

<p>キーの型と値の型からオブジェクトの型を生成できます。
<code class="language-plaintext highlighter-rouge">{[P in K]: T}</code> のようにして表現します。
<code class="language-plaintext highlighter-rouge">K</code> は string・number・symbol の部分型である必要があります。</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Hoge</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">P</span> <span class="k">in</span> <span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">]:</span> <span class="kr">string</span> <span class="p">};</span>

<span class="kd">const</span> <span class="nx">obj</span><span class="p">:</span> <span class="nx">Hoge</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">foo</span><span class="p">:</span> <span class="dl">"</span><span class="s2">taro</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">bar</span><span class="p">:</span> <span class="dl">"</span><span class="s2">jiro</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">K</code> 型の値として可能な各文字列 <code class="language-plaintext highlighter-rouge">P</code> に対して、型 <code class="language-plaintext highlighter-rouge">T</code> を持つプロパティ <code class="language-plaintext highlighter-rouge">P</code> が存在するようなオブジェクトの型を意味しています。
上記の例では、 <code class="language-plaintext highlighter-rouge">{ foo: string, bar: string }</code> という型を表しています。</p>

<h4 id="演習問題-5">演習問題</h4>

<p><code class="language-plaintext highlighter-rouge">/typescript/src/advanced/exercise6.ts</code> を解いてみてください。</p>

<details><summary>Advanced</summary>

- TypeScript が提供している `Utility Types` の `Partial<T>` は mapped types を用いて実装されている。
- `Partial<T>` は `T` の全てのパラメータを optional にした型を返す。
  - 演習問題 (Ex.10) では、 `Partial<T>` を使わずにチャレンジしてみよう

```ts
type Hoge = {
  foo: string;
  bar: number;
};

type OptionalHoge = Partial<Hoge>; // { foo?: string, bar?: number }
```

&lt;/details&gt;

### Conditional-Types（☆）

型レベルの条件分岐が可能な型です。
`T extends U ? X : Y` のようにして表現します。
この型は `T` が `U` の部分型ならば `X` に、そうでなければ `Y` になります。
三項演算子と同様の記法を用います。

```ts
type Diff&lt;T, U&gt; = T extends U ? never : T;
type RequiredKeys = Diff&lt;"age" | "name", "age"&gt;; // 'name'
```

上記の例は `Conditional Type` を用いて、 `T` に指定した型から、 `U` に指定した型を取り除く型 `Diff` を定義しています。
`RequiredKeys` は、 `T` に指定した `'age' | 'name'` から、 `U` に指定した `'age'` を取り除いた `'name'` の型を表しています。

`T` を一つずつ取り出して、 `T extends U ? X : Y` の形で推測を行なっています。
上記の `Diff` 型は以下のようになっています。

```ts
type Diff =
  | ("age" extends "age" ? never : "age")
  | ("name" extends "age" ? never : "name");
```

`'age'` は `'age'` 型 なので `never` が返って来ます。
`'name'` は `'age'` 型 ではないので `'name'` が返って来ます。

```ts
type Diff = never | "name";
```

`never` は union 型からは除外されるようになっているため

```ts
type Diff = "name";
```

となり、 `RequiredKeys` の型は `'name'` となります。

#### 演習問題

`/typescript/src/advanced/exercise7.ts` を解いてみてください。

## Non-null assertion（☆☆）

その変数が `undefined` , `null` ではない事をコンパイラに伝える記法です。
要素の後ろに `!` を記述して表現します。

```ts
const message1 = "hello" as string | null;
const message2 = "hello" as string | null;
const message3 = null as string | null;

message1.toUpperCase(); // コンパイルエラーになるが、ランタイムエラーにならない
message2!.toUpperCase(); // コンパイルエラーにならず、ランタイムエラーにならない
message3!.toUpperCase(); // コンパイルエラーにならず、ランタイムエラーになる
```

コンパイラに「この要素は存在する」と伝えるため、 要素が `null` であることによるコンパイルエラーが発生しません。
そのため、実装者が要素の存在を担保できる場合にのみ使うことが望ましいです。

### 演習問題

`/typescript/src/advanced/exercise8.ts` を解いてみてください。

## Optional Chaining（☆☆☆☆☆）

null/undefined のチェックを楽に書ける記法です。
null/undefined になり得る要素の後ろに `?` を記述して表現します。

```ts
type Hoge = {
  foo?: {
    bar: string;
  };
};

const obj: Hoge = {
  foo: {
    bar: "taro",
  },
};

const string = obj.foo?.bar;
// Optional Chaining を使わない場合
// const string = obj.foo &amp;&amp; obj.foo.bar // 論理演算子を使っている
```

### 演習問題

`/typescript/src/advanced/exercise9.ts` を解いてみてください。

## Nullish Coalescing（☆☆☆☆）

短絡評価を null と undefined に制限して評価する記法です。
`??` を用いて表現します。
空文字列や `0` の場合に論理演算子で起こり得るバグを防げます。

`foo` が存在しなければ `bar` を返す記述を例にすると

```ts
// 論理演算子で書いた例
const result = foo || bar;
// これは以下と同義
const result = foo ? foo : bar;
```

この場合 `foo` が空文字列や `0` の場合でも `bar` を返してしまいます。
`result` が 空文字列や `0` も期待している場合はエラーの温床となってしまいます。

```ts
// Nullish Coalescing を用いて、空文字列、0の場合も foo を返せるようにする
const result = foo ?? bar;
```

### 演習問題

`/typescript/src/advanced/exercise10.ts` を解いてみてください。

<!-- ## 時間が余った時用

`/typescript/src/sp` に研修振り返り用の問題を用意しています。
解いてみてください。

問題は拝借してきたものです。
教え切れてない内容もあるのでググっても OK、ただし答えを探すのは NG！

## level1

- 理解確認用の問題
- 講義内容が理解出来ていれば簡単

問題は、 `/typescript/src/sp/level1/` にあります。今までの演習問題同様に実行して確認して下さい。

## level2

- 基礎の問題
- 少し考える必要が出てくるかも？

問題は、 `/typescript/src/sp/level2/` にあります。今までの演習問題同様に実行して確認して下さい。

## level3

- 脱入門のレベル
- 解ければ TypeScript の基礎は完全に理解出来てそう

問題は、 `/typescript/src/sp/level3/` にあります。今までの演習問題同様に実行して確認して下さい。 -->
</Hoge></T></T></T></details>


      <footer class="site-footer">
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </main>
  </body>
</html>
